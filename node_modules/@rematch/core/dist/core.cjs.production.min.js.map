{"version":3,"file":"core.cjs.production.min.js","sources":["../src/reduxStore.ts","../src/dispatcher.ts","../src/rematchStore.ts","../src/config.ts","../src/index.ts","../src/bag.ts"],"sourcesContent":["import * as Redux from 'redux'\nimport {\n\tAction,\n\tConfigRedux,\n\tModelReducers,\n\tNamedModel,\n\tRematchBag,\n\tDevtoolOptions,\n\tModels,\n\tRematchRootState,\n} from './types'\n\n/**\n * Creates 'combined' reducer for each model and then merges those reducers\n * together into a 'root' reducer. It then creates a Redux store with\n * middlewares and enhancers.\n */\nexport default function createReduxStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tRootState = RematchRootState<TModels, TExtraModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Store<RootState> {\n\tbag.models.forEach((model) => createModelReducer(bag, model))\n\n\tconst rootReducer = createRootReducer<RootState, TModels, TExtraModels>(bag)\n\n\tconst middlewares = Redux.applyMiddleware(...bag.reduxConfig.middlewares)\n\tconst enhancers = bag.reduxConfig.devtoolComposer\n\t\t? bag.reduxConfig.devtoolComposer(...bag.reduxConfig.enhancers, middlewares)\n\t\t: composeEnhancersWithDevtools(bag.reduxConfig.devtoolOptions)(\n\t\t\t\t...bag.reduxConfig.enhancers,\n\t\t\t\tmiddlewares\n\t\t  )\n\n\tconst createStore = bag.reduxConfig.createStore || Redux.createStore\n\tconst bagInitialState = bag.reduxConfig.initialState\n\tconst initialState = bagInitialState === undefined ? {} : bagInitialState\n\n\treturn createStore<RootState, Action, any, typeof initialState>(\n\t\trootReducer,\n\t\tinitialState,\n\t\tenhancers\n\t)\n}\n\n/**\n * Creates a combined reducer for a given model. What it means is that:\n * - it forms an action name for each model's reducer as 'modelName/reducerKey'\n * - it creates a mapping from action name to its reducer\n * - it wraps the mapping with a function (combined reducer) that selects and\n *   runs a reducer based on the incoming action\n * - if the model also has a base reducer defined, it creates a function which\n *   first runs the incoming action through this reducer and then passes the\n *   resulting state and the same action to combined reducer\n *\n * The final result - a function, is returned.\n */\nexport function createModelReducer<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTState extends NamedModel<TModels>['state'] = any\n>(bag: RematchBag<TModels, TExtraModels>, model: NamedModel<TModels>): void {\n\tconst modelReducers: ModelReducers<TState> = {}\n\n\t// build action name for each reducer and create mapping from name to reducer\n\tconst modelReducerKeys = Object.keys(model.reducers)\n\tmodelReducerKeys.forEach((reducerKey) => {\n\t\tconst actionName = isAlreadyActionName(reducerKey)\n\t\t\t? reducerKey\n\t\t\t: `${model.name}/${reducerKey}`\n\n\t\tmodelReducers[actionName] = model.reducers[reducerKey]\n\t})\n\n\t// select and run a reducer based on the incoming action\n\tconst combinedReducer = (\n\t\tstate: TState = model.state,\n\t\taction: Action\n\t): TState => {\n\t\tif (action.type in modelReducers) {\n\t\t\treturn modelReducers[action.type](\n\t\t\t\tstate,\n\t\t\t\taction.payload,\n\t\t\t\taction.meta\n\t\t\t\t// we use augmentation because a reducer can return void due immer plugin,\n\t\t\t\t// which makes optional returning the reducer state\n\t\t\t) as TState\n\t\t}\n\n\t\treturn state\n\t}\n\n\tconst modelBaseReducer = model.baseReducer\n\n\t// when baseReducer is defined, run the action first through it\n\tlet reducer = !modelBaseReducer\n\t\t? combinedReducer\n\t\t: (state: TState = model.state, action: Action): TState =>\n\t\t\t\tcombinedReducer(modelBaseReducer(state, action), action)\n\n\tbag.forEachPlugin('onReducer', (onReducer) => {\n\t\treducer = onReducer(reducer, model.name, bag) || reducer\n\t})\n\n\tbag.reduxConfig.reducers[model.name] = reducer\n}\n\n/**\n * It merges all reducers in config using mergeReducers function. Additionally,\n * if user supplied any rootReducers, a wrapper function around merged reducers\n * is created. It first feeds each into its corresponding 'root' reducer (if\n * it's available), and then passes on the resulting state to the merged reducer.\n */\nexport function createRootReducer<\n\tTRootState,\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Reducer<TRootState, Action> {\n\tconst { rootReducers } = bag.reduxConfig\n\tconst mergedReducers = mergeReducers<TRootState>(bag.reduxConfig)\n\tlet rootReducer = mergedReducers\n\n\tif (rootReducers && Object.keys(rootReducers).length) {\n\t\trootReducer = (\n\t\t\tstate: TRootState | undefined,\n\t\t\taction: Action\n\t\t): TRootState => {\n\t\t\tconst actionRootReducer = rootReducers[action.type]\n\n\t\t\tif (actionRootReducer) {\n\t\t\t\treturn mergedReducers(actionRootReducer(state, action), action)\n\t\t\t}\n\n\t\t\treturn mergedReducers(state, action)\n\t\t}\n\t}\n\n\tbag.forEachPlugin('onRootReducer', (onRootReducer) => {\n\t\trootReducer = onRootReducer(rootReducer, bag) || rootReducer\n\t})\n\n\treturn rootReducer\n}\n\n/**\n * Merges all reducers defined in config into one function using user supplied\n * or default combineReducers function.\n * If there are no reducers defined, it returns a function that just returns\n * the state for all incoming actions.\n */\nfunction mergeReducers<TRootState>(\n\treduxConfig: ConfigRedux<TRootState>\n): Redux.Reducer<TRootState, Action> {\n\tconst combineReducers = reduxConfig.combineReducers || Redux.combineReducers\n\n\tif (!Object.keys(reduxConfig.reducers).length) {\n\t\treturn (state: any): TRootState => state\n\t}\n\n\treturn combineReducers(reduxConfig.reducers as Redux.ReducersMapObject)\n}\n\n/**\n * Returns Redux Devtools compose method unless it's disabled, in which case it\n * returns default Redux.compose.\n */\nfunction composeEnhancersWithDevtools(\n\tdevtoolOptions: DevtoolOptions = {}\n): (...args: any[]) => Redux.StoreEnhancer {\n\treturn !devtoolOptions.disabled &&\n\t\ttypeof window === 'object' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devtoolOptions)\n\t\t: Redux.compose\n}\n\n/**\n * Determines if a reducer key is already an action name, for example -\n * a listener on another model.\n */\nfunction isAlreadyActionName(reducerKey: string): boolean {\n\treturn reducerKey.indexOf('/') > -1\n}\n","import {\n\tAction,\n\tModelEffects,\n\tModelEffectsCreator,\n\tModels,\n\tNamedModel,\n\tRematchBag,\n\tRematchDispatcher,\n\tRematchStore,\n} from './types'\nimport { validateModelEffect, validateModelReducer } from './validate'\n\n/**\n * Builds a dispatcher for given model name and action name. The dispatched\n * action will have a type `modelName/actionName`.\n * Additionally, adds the isEffect property to the created dispatcher.\n * isEffect helps to differentiate effects dispatchers from reducer dispatchers.\n */\nconst createActionDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tmodelName: string,\n\tactionName: string,\n\tisEffect: boolean\n): RematchDispatcher<boolean> => {\n\treturn Object.assign(\n\t\t(payload?: any, meta?: any): Action => {\n\t\t\tconst action: Action = { type: `${modelName}/${actionName}` }\n\n\t\t\tif (typeof payload !== 'undefined') {\n\t\t\t\taction.payload = payload\n\t\t\t}\n\n\t\t\tif (typeof meta !== 'undefined') {\n\t\t\t\taction.meta = meta\n\t\t\t}\n\n\t\t\treturn rematch.dispatch(action)\n\t\t},\n\t\t{\n\t\t\tisEffect,\n\t\t}\n\t)\n}\n\n/**\n * Creates a dispatcher object for a model - it contains a mapping from all\n * reducers to functions which dispatch their corresponding actions.\n */\nexport const createReducerDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\n\t// map reducer names to dispatch actions\n\tconst modelReducersKeys = Object.keys(model.reducers)\n\tmodelReducersKeys.forEach((reducerName) => {\n\t\tvalidateModelReducer(model.name, model.reducers, reducerName)\n\n\t\tmodelDispatcher[reducerName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\treducerName,\n\t\t\tfalse\n\t\t)\n\t})\n}\n\n/**\n * Creates effects dispatcher for a model - it contains a mapping from all\n * effects *names* to functions which dispatch their corresponding actions.\n */\nexport const createEffectDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\tlet effects: ModelEffects<TModels> = {}\n\n\t// 'effects' might be actually a function creating effects\n\tif (model.effects) {\n\t\teffects =\n\t\t\ttypeof model.effects === 'function'\n\t\t\t\t? (model.effects as ModelEffectsCreator<TModels>)(rematch.dispatch)\n\t\t\t\t: model.effects\n\t}\n\n\t// map effects names to dispatch actions\n\tconst effectKeys = Object.keys(effects)\n\teffectKeys.forEach((effectName) => {\n\t\tvalidateModelEffect(model.name, effects, effectName)\n\n\t\tbag.effects[`${model.name}/${effectName}`] =\n\t\t\teffects[effectName].bind(modelDispatcher)\n\n\t\tmodelDispatcher[effectName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\teffectName,\n\t\t\ttrue\n\t\t)\n\t})\n}\n","import { Middleware } from 'redux'\nimport {\n\tAction,\n\tConfig,\n\tExposedFunction,\n\tModels,\n\tNamedModel,\n\tObjectNotAFunction,\n\tPlugin,\n\tRematchBag,\n\tRematchStore,\n\tModelDispatcher,\n\tRematchDispatch,\n} from './types'\nimport createReduxStore, {\n\tcreateModelReducer,\n\tcreateRootReducer,\n} from './reduxStore'\nimport { createReducerDispatcher, createEffectDispatcher } from './dispatcher'\nimport { validateModel } from './validate'\nimport createRematchBag from './bag'\n\nexport default function createRematchStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchStore<TModels, TExtraModels> {\n\t// setup rematch 'bag' for storing useful values and functions\n\tconst bag = createRematchBag(config)\n\n\t// add middleware for handling effects\n\tbag.reduxConfig.middlewares.push(createEffectsMiddleware(bag))\n\n\t// collect middlewares from plugins\n\tbag.forEachPlugin('createMiddleware', (createMiddleware) => {\n\t\tbag.reduxConfig.middlewares.push(createMiddleware(bag))\n\t})\n\n\tconst reduxStore = createReduxStore(bag)\n\n\tlet rematchStore = {\n\t\t...reduxStore,\n\t\tname: config.name,\n\t\taddModel(model: NamedModel<TModels>) {\n\t\t\tvalidateModel(model)\n\t\t\tcreateModelReducer(bag, model)\n\t\t\tprepareModel(rematchStore, model)\n\t\t\tenhanceModel(rematchStore, bag, model)\n\t\t\treduxStore.replaceReducer(createRootReducer(bag))\n\t\t\treduxStore.dispatch({ type: '@@redux/REPLACE' })\n\t\t},\n\t} as RematchStore<TModels, TExtraModels>\n\n\taddExposed(rematchStore, config.plugins)\n\n\t/**\n\t * generate dispatch[modelName][actionName] for all reducers and effects\n\t *\n\t * Note: To have circular models accessible in effects method with destructing,\n\t *       ensure that model generation and effects generation execute in\n\t *       different steps.\n\t */\n\tbag.models.forEach((model) => prepareModel(rematchStore, model))\n\tbag.models.forEach((model) => enhanceModel(rematchStore, bag, model))\n\n\tbag.forEachPlugin('onStoreCreated', (onStoreCreated) => {\n\t\trematchStore = onStoreCreated(rematchStore, bag) || rematchStore\n\t})\n\n\treturn rematchStore\n}\n\nfunction createEffectsMiddleware<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Middleware {\n\treturn (store) =>\n\t\t(next) =>\n\t\t(action: Action): any => {\n\t\t\tif (action.type in bag.effects) {\n\t\t\t\t// first run reducer action if exists\n\t\t\t\tnext(action)\n\n\t\t\t\t// then run the effect and return its result\n\t\t\t\treturn (bag.effects as any)[action.type](\n\t\t\t\t\taction.payload,\n\t\t\t\t\tstore.getState(),\n\t\t\t\t\taction.meta\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn next(action)\n\t\t}\n}\n\nfunction prepareModel<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(rematchStore: RematchStore<TModels, TExtraModels>, model: TModel): void {\n\tconst modelDispatcher = {} as ModelDispatcher<TModel, TModels>\n\n\t// inject model so effects creator can access it\n\trematchStore.dispatch[`${model.name}` as keyof RematchDispatch<TModels>] =\n\t\tmodelDispatcher\n\n\tcreateReducerDispatcher(rematchStore, model)\n}\n\nfunction enhanceModel<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematchStore: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void {\n\tcreateEffectDispatcher(rematchStore, bag, model)\n\n\tbag.forEachPlugin('onModel', (onModel) => {\n\t\tonModel(model, rematchStore)\n\t})\n}\n\n/**\n * Adds properties exposed by plugins into the Rematch instance. If a exposed\n * property is a function, it passes rematch as the first argument.\n *\n * If you're implementing a plugin in TypeScript, extend Rematch namespace by\n * adding the properties that you exposed from your plugin.\n */\nfunction addExposed<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tstore: RematchStore<TModels, TExtraModels>,\n\tplugins: Plugin<TModels, TExtraModels>[]\n): void {\n\tplugins.forEach((plugin) => {\n\t\tif (!plugin.exposed) return\n\t\tconst pluginKeys = Object.keys(plugin.exposed)\n\t\tpluginKeys.forEach((key) => {\n\t\t\tif (!plugin.exposed) return\n\t\t\tconst exposedItem = plugin.exposed[key] as\n\t\t\t\t| ExposedFunction<TModels, TExtraModels>\n\t\t\t\t| ObjectNotAFunction\n\t\t\tconst isExposedFunction = typeof exposedItem === 'function'\n\n\t\t\tstore[key] = isExposedFunction\n\t\t\t\t? (...params: any[]): any =>\n\t\t\t\t\t\t(exposedItem as ExposedFunction<TModels, TExtraModels>)(\n\t\t\t\t\t\t\tstore,\n\t\t\t\t\t\t\t...params\n\t\t\t\t\t\t)\n\t\t\t\t: Object.create(plugin.exposed[key])\n\t\t})\n\t})\n}\n","import { InitConfig, Config, Models } from './types'\nimport { validateConfig, validatePlugin } from './validate'\n\nlet count = 0\n\n/**\n * Builds complete Rematch config using default values for properties not\n * supplied by the user. Additionally, applies changes to the config made by\n * the plugins selected by the user.\n */\nexport default function createConfig<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tinitConfig: InitConfig<TModels, TExtraModels>\n): Config<TModels, TExtraModels> {\n\tconst storeName = initConfig.name ?? `Rematch Store ${count}`\n\n\tcount += 1\n\n\tconst config = {\n\t\tname: storeName,\n\t\tmodels: initConfig.models || {},\n\t\tplugins: initConfig.plugins || [],\n\t\tredux: {\n\t\t\treducers: {},\n\t\t\trootReducers: {},\n\t\t\tenhancers: [],\n\t\t\tmiddlewares: [],\n\t\t\t...initConfig.redux,\n\t\t\tdevtoolOptions: {\n\t\t\t\tname: storeName,\n\t\t\t\t...(initConfig.redux?.devtoolOptions ?? {}),\n\t\t\t},\n\t\t},\n\t} as Config<TModels, TExtraModels>\n\n\tvalidateConfig(config)\n\n\t// Apply changes to the config required by plugins\n\tconfig.plugins.forEach((plugin) => {\n\t\tif (plugin.config) {\n\t\t\t// Collect new models\n\t\t\tconfig.models = merge(config.models, plugin.config.models)\n\n\t\t\t// Collect redux configuration changes\n\t\t\tif (plugin.config.redux) {\n\t\t\t\tconfig.redux.initialState = merge(\n\t\t\t\t\tconfig.redux.initialState,\n\t\t\t\t\tplugin.config.redux.initialState\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.reducers = merge(\n\t\t\t\t\tconfig.redux.reducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.rootReducers = merge(\n\t\t\t\t\tconfig.redux.rootReducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.enhancers = [\n\t\t\t\t\t...config.redux.enhancers,\n\t\t\t\t\t...(plugin.config.redux.enhancers || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.middlewares = [\n\t\t\t\t\t...config.redux.middlewares,\n\t\t\t\t\t...(plugin.config.redux.middlewares || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.combineReducers =\n\t\t\t\t\tconfig.redux.combineReducers || plugin.config.redux.combineReducers\n\n\t\t\t\tconfig.redux.createStore =\n\t\t\t\t\tconfig.redux.createStore || plugin.config.redux.createStore\n\t\t\t}\n\t\t}\n\n\t\tvalidatePlugin(plugin)\n\t})\n\n\treturn config as Config<TModels, TExtraModels>\n}\n\n/**\n * Shallow merges original object with the extra object, giving the precedence\n * to the original object.\n */\nfunction merge<\n\tT extends Record<string, unknown>,\n\tU extends Record<string, unknown> = T\n>(original: T, extra?: U): T | (T & U) {\n\treturn extra ? { ...extra, ...original } : original\n}\n","import createRematchStore from './rematchStore'\nimport { InitConfig, Models, RematchStore, ModelCreator } from './types'\nimport createConfig from './config'\n\n/**\n * Prepares a complete configuration and creates a Rematch store.\n */\nexport const init = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels> = Record<string, never>\n>(\n\tinitConfig?: InitConfig<TModels, TExtraModels>\n): RematchStore<TModels, TExtraModels> => {\n\tconst config = createConfig(initConfig || {})\n\treturn createRematchStore(config)\n}\n\nexport const createModel: ModelCreator = () => (mo) => mo as any\n\nexport default {\n\tinit,\n\tcreateModel,\n}\n\nexport * from './types'\n","import { Config, Model, Models, NamedModel, RematchBag } from './types'\nimport { validateModel } from './validate'\n\n/**\n * Creates and returns a 'Rematch Bag', which is a set of configuration options\n * used by the Rematch library in various functions.\n */\nexport default function createRematchBag<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchBag<TModels, TExtraModels> {\n\treturn {\n\t\tmodels: createNamedModels(config.models),\n\t\treduxConfig: config.redux,\n\t\tforEachPlugin(method, fn): void {\n\t\t\tconfig.plugins.forEach((plugin) => {\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tfn(plugin[method]!)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\teffects: {},\n\t}\n}\n\n/**\n * Transforms mapping from a model name to a model object, into an array of\n * 'named' models - models with embedded name and default value for reducers\n * if user didn't provide any.\n */\nfunction createNamedModels<TModels extends Models<TModels>>(\n\tmodels: TModels | Partial<TModels>\n): NamedModel<TModels>[] {\n\treturn Object.keys(models).map((modelName: string) => {\n\t\tconst model = createNamedModel(modelName, (models as TModels)[modelName])\n\t\tvalidateModel(model)\n\t\treturn model\n\t})\n}\n\n/**\n * Transforms a model into 'named' model - model which contains 'name' and\n * 'reducers' properties if user didn't provide any.\n */\nfunction createNamedModel<TModels extends Models<TModels>>(\n\tname: string,\n\tmodel: Model<TModels>\n): NamedModel<TModels> {\n\treturn {\n\t\tname,\n\t\treducers: {},\n\t\t...model,\n\t}\n}\n"],"names":["createModelReducer","bag","model","modelReducers","Object","keys","reducers","forEach","reducerKey","actionName","indexOf","isAlreadyActionName","name","combinedReducer","state","action","type","payload","meta","modelBaseReducer","baseReducer","reducer","forEachPlugin","onReducer","reduxConfig","createRootReducer","combineReducers","rootReducers","mergedReducers","Redux","length","rootReducer","actionRootReducer","onRootReducer","createActionDispatcher","rematch","modelName","isEffect","assign","dispatch","prepareModel","rematchStore","modelDispatcher","reducerName","createReducerDispatcher","enhanceModel","effects","effectName","bind","createEffectDispatcher","onModel","count","merge","original","extra","init","initConfig","config","storeName","models","plugins","redux","enhancers","middlewares","devtoolOptions","_initConfig$redux","plugin","initialState","createStore","createConfig","map","method","fn","createRematchBag","push","store","next","getState","createEffectsMiddleware","createMiddleware","reduxStore","applyMiddleware","devtoolComposer","disabled","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","bagInitialState","undefined","createReduxStore","addModel","replaceReducer","exposed","key","exposedItem","params","create","onStoreCreated","createRematchStore","createModel","mo"],"mappings":"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"}
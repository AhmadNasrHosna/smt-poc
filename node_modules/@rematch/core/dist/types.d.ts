import { Action as ReduxAction, Reducer as ReduxReducer, Dispatch as ReduxDispatch, ReducersMapObject, Middleware, StoreEnhancer, StoreCreator, Store as ReduxStore, ActionCreator } from 'redux';
declare type CheckIfParameterOptional<P> = P extends [unknown, ...unknown[]] ? false : true;
declare type Without<FirstType, SecondType> = {
    [KeyType in Exclude<keyof FirstType, keyof SecondType>]: never;
};
export declare type MergeExclusive<FirstType, SecondType> = FirstType | SecondType extends object ? (Without<FirstType, SecondType> & SecondType) | (Without<SecondType, FirstType> & FirstType) : FirstType | SecondType;
export interface Action<TPayload = any, TMeta = any> extends ReduxAction<string> {
    payload?: TPayload;
    meta?: TMeta;
}
export declare type Reducer<TState = any> = (state: TState, payload?: Action['payload'], meta?: Action['meta']) => TState | void;
export interface Models<TModels extends Models<TModels>> {
    [key: string]: Model<TModels>;
}
export interface NamedModel<TModels extends Models<TModels>, TState = any, TBaseState = TState> extends Model<TModels, TState, TBaseState> {
    name: string;
    reducers: ModelReducers<TState>;
}
export interface Model<TModels extends Models<TModels>, TState = any, TBaseState = TState> {
    name?: string;
    state: TState;
    reducers?: ModelReducers<TState>;
    baseReducer?: ReduxReducer<TBaseState>;
    effects?: ModelEffects<TModels> | ModelEffectsCreator<TModels>;
}
export declare type ModelReducers<TState = any> = {
    [key: string]: Reducer<TState>;
};
export interface ModelEffects<TModels extends Models<TModels>> {
    [key: string]: ModelEffect<TModels>;
}
export declare type ModelEffectThisTyped = {
    [key: string]: (payload?: any, meta?: any) => Action<any, any>;
};
export declare type ModelEffect<TModels extends Models<TModels>> = (this: ModelEffectThisTyped, payload: Action['payload'], rootState: RematchRootState<TModels>, meta: Action['meta']) => any;
export declare type ModelEffectsCreator<TModels extends Models<TModels>> = (dispatch: RematchDispatch<TModels>) => ModelEffects<TModels>;
export interface PluginConfig<TModels extends Models<TModels>, TExtraModels extends Models<TModels>, TExposedModels = Partial<TExtraModels>> {
    models?: TExposedModels;
    redux?: InitConfigRedux;
}
export interface Plugin<TModels extends Models<TModels>, TExtraModels extends Models<TModels> = Record<string, never>, TExposedModels = Partial<TExtraModels>> extends PluginHooks<TModels, TExtraModels> {
    config?: PluginConfig<TModels, TExtraModels, TExposedModels>;
    exposed?: PluginExposed<TModels, TExtraModels>;
}
export interface PluginHooks<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> {
    onStoreCreated?: StoreCreatedHook<TModels, TExtraModels>;
    onModel?: ModelHook<TModels, TExtraModels>;
    onReducer?: ReducerHook<TModels, TExtraModels>;
    onRootReducer?: RootReducerHook<TModels, TExtraModels>;
    createMiddleware?: MiddlewareCreator<TModels, TExtraModels>;
}
export declare type ModelHook<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = (model: NamedModel<TModels>, rematch: RematchStore<TModels, TExtraModels>) => void;
export declare type ReducerHook<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = (reducer: ReduxReducer, modelName: string, rematch: RematchBag<TModels, TExtraModels>) => ReduxReducer | void;
export declare type RootReducerHook<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = (reducer: ReduxReducer, rematch: RematchBag<TModels, TExtraModels>) => ReduxReducer | void;
export declare type StoreCreatedHook<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = (store: RematchStore<TModels, TExtraModels>, rematch: RematchBag<TModels, TExtraModels>) => RematchStore<TModels, TExtraModels> | void;
export declare type MiddlewareCreator<TModels extends Models<TModels>, TExtraModels extends Models<TModels> = Record<string, never>> = (rematch: RematchBag<TModels, TExtraModels>) => Middleware;
export declare type ObjectNotAFunction = {
    [k: string]: any;
} & ({
    bind?: never;
} | {
    call?: never;
});
export declare type PluginExposed<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = {
    [key: string]: ExposedFunction<TModels, TExtraModels> | ObjectNotAFunction;
};
export declare type ExposedFunction<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = (rematch: RematchStore<TModels, TExtraModels>, ...args: any) => any;
export interface RematchBag<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> {
    models: NamedModel<TModels>[];
    reduxConfig: ConfigRedux;
    forEachPlugin: <Hook extends keyof PluginHooks<TModels, TExtraModels>>(method: Hook, fn: (content: NonNullable<PluginHooks<TModels, TExtraModels>[Hook]>) => void) => void;
    effects: ModelEffects<TModels>;
}
export interface InitConfig<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> {
    name?: string;
    models?: TModels | Partial<TModels>;
    plugins?: Plugin<TModels, TExtraModels>[];
    redux?: InitConfigRedux;
}
export interface Config<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> extends InitConfig<TModels, TExtraModels> {
    name: string;
    models: TModels | Partial<TModels>;
    plugins: Plugin<TModels, TExtraModels>[];
    redux: ConfigRedux;
}
export interface InitConfigRedux<TRootState = any, DevtoolComposerGeneric = any> {
    initialState?: TRootState;
    reducers?: ModelReducers<TRootState>;
    enhancers?: StoreEnhancer[];
    middlewares?: Middleware[];
    rootReducers?: ReducersMapObject<TRootState, Action>;
    combineReducers?: ((reducers: ReducersMapObject<TRootState, Action>) => ReduxReducer<TRootState>) | undefined;
    createStore?: StoreCreator | undefined;
    devtoolOptions?: DevtoolOptions;
    devtoolComposer?: DevtoolComposerGeneric;
}
export interface ConfigRedux<TRootState = any> extends InitConfigRedux<TRootState> {
    reducers: ModelReducers<TRootState>;
    enhancers: StoreEnhancer[];
    middlewares: Middleware[];
    rootReducers: ReducersMapObject<TRootState, Action>;
}
export interface RematchStore<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> extends ReduxStore<RematchRootState<TModels, TExtraModels>, Action> {
    [index: string]: ExposedFunction<TModels, TExtraModels> | Record<string, any> | string;
    name: string;
    dispatch: RematchDispatch<TModels>;
    addModel: (model: NamedModel<TModels>) => void;
}
export declare type RematchRootState<TModels extends Models<TModels>, TExtraModels extends Models<TModels> = Record<string, never>> = ExtractRematchStateFromModels<TModels, TExtraModels>;
export declare type ExtractRematchStateFromModels<TModels extends Models<TModels>, TExtraModels extends Models<TModels>> = {
    [modelKey in keyof TModels]: TModels[modelKey]['state'];
} & {
    [modelKey in keyof TExtraModels]: TExtraModels[modelKey]['state'];
};
export declare type RematchDispatch<TModels extends Models<TModels>> = ReduxDispatch & ExtractRematchDispatchersFromModels<TModels>;
export declare type ExtractRematchDispatchersFromModels<TModels extends Models<TModels>> = {
    [modelKey in keyof TModels]: TModels[modelKey] extends Model<TModels> ? ModelDispatcher<TModels[modelKey], TModels> : never;
};
export declare type ModelDispatcher<TModel extends Model<TModels>, TModels extends Models<TModels>> = MergeExclusive<ExtractRematchDispatchersFromEffects<TModel['effects'], TModels>, ExtractRematchDispatchersFromReducers<TModel['state'], TModel['reducers'], TModels>>;
export declare type ReturnOfDispatcher<IsEffect extends boolean, TReturn = any, TPayload = void, TMeta = void> = IsEffect extends true ? TReturn : Action<TPayload, TMeta>;
export declare type RematchDispatcher<IsEffect extends boolean, TPayload extends [p?: unknown] = never, TMeta extends [m?: unknown] = never, TReturn = any> = [TPayload, TMeta] extends [never, never] ? (() => ReturnOfDispatcher<IsEffect, TReturn>) & {
    isEffect: IsEffect;
} : [TMeta] extends [never] ? CheckIfParameterOptional<TPayload> extends true ? ((payload?: TPayload[0]) => ReturnOfDispatcher<IsEffect, TReturn, TPayload[0]>) & {
    isEffect: IsEffect;
} : ((payload: TPayload[0]) => ReturnOfDispatcher<IsEffect, TReturn, TPayload[0]>) & {
    isEffect: IsEffect;
} : CheckIfParameterOptional<TMeta> extends true ? CheckIfParameterOptional<TPayload> extends true ? ((payload?: TPayload[0], meta?: TMeta[0]) => ReturnOfDispatcher<IsEffect, TReturn, TPayload[0], TMeta[0]>) & {
    isEffect: IsEffect;
} : ((payload: TPayload[0], meta?: TMeta[0]) => ReturnOfDispatcher<IsEffect, TReturn, TPayload[0], TMeta[0]>) & {
    isEffect: IsEffect;
} : ((payload: TPayload[0], meta: TMeta[0]) => ReturnOfDispatcher<IsEffect, TReturn, TPayload[0], TMeta[0]>) & {
    isEffect: IsEffect;
};
declare type ExtractParameterFromReducer<P extends unknown[], V extends 'payload' | 'meta'> = P extends [] ? never : P extends [p?: infer TPayload] ? V extends 'payload' ? P extends [infer TPayloadMayUndefined, ...unknown[]] ? [p: TPayloadMayUndefined] : [p?: TPayload] : never : P extends [p?: infer TPayload, m?: infer TMeta, ...args: unknown[]] ? V extends 'payload' ? P extends [infer TPayloadMayUndefined, ...unknown[]] ? [p: TPayloadMayUndefined] : [p?: TPayload] : P extends [unknown, infer TMetaMayUndefined, ...unknown[]] ? [m: TMetaMayUndefined] : [m?: TMeta] : never;
export declare type ExtractRematchDispatchersFromReducers<TState, TReducers extends Model<TModels, TState>['reducers'], TModels extends Models<TModels>> = {
    [reducerKey in keyof TReducers]: ExtractRematchDispatcherFromReducer<TState, TReducers[reducerKey]>;
};
export declare type ExtractRematchDispatcherFromReducer<TState, TReducer> = TReducer extends () => any ? RematchDispatcher<false> : TReducer extends (state: TState, ...args: infer TRest) => TState | void ? TRest extends [] ? RematchDispatcher<false> : TRest[1] extends undefined ? RematchDispatcher<false, ExtractParameterFromReducer<TRest, 'payload'>> : RematchDispatcher<false, ExtractParameterFromReducer<TRest, 'payload'>, ExtractParameterFromReducer<TRest, 'meta'>> : never;
export declare type ExtractRematchDispatchersFromEffects<TEffects extends Model<TModels>['effects'], TModels extends Models<TModels>> = TEffects extends (...args: any[]) => infer R ? R extends ModelEffects<TModels> ? ExtractRematchDispatchersFromEffectsObject<R, TModels> : never : TEffects extends ModelEffects<TModels> ? ExtractRematchDispatchersFromEffectsObject<TEffects, TModels> : never;
export declare type ExtractRematchDispatchersFromEffectsObject<TEffects extends ModelEffects<TModels>, TModels extends Models<TModels>> = {
    [effectKey in keyof TEffects]: ExtractRematchDispatcherFromEffect<TEffects[effectKey], TModels>;
};
declare type ExtractParameterFromEffect<P extends unknown[], V extends 'payload' | 'meta'> = P extends [] ? never : P extends [p?: infer TPayload, s?: unknown] ? V extends 'payload' ? P extends [infer TPayloadMayUndefined, ...unknown[]] ? [p: TPayloadMayUndefined] : [p?: TPayload] : never : P extends [
    p?: infer TPayload,
    s?: unknown,
    m?: infer TMeta,
    ...args: unknown[]
] ? V extends 'payload' ? P extends [infer TPayloadMayUndefined, ...unknown[]] ? [p: TPayloadMayUndefined] : [p?: TPayload] : P extends [unknown, unknown, infer TMetaMayUndefined, ...unknown[]] ? [m: TMetaMayUndefined] : [m?: TMeta] : never;
export declare type ExtractRematchDispatcherFromEffect<TEffect extends ModelEffect<TModels>, TModels extends Models<TModels>> = TEffect extends (...args: infer TRest) => infer TReturn ? TRest extends [] ? RematchDispatcher<true, never, never, TReturn> : TRest[1] extends undefined ? RematchDispatcher<true, ExtractParameterFromEffect<TRest, 'payload'>, never, TReturn> : TRest[2] extends undefined ? RematchDispatcher<true, ExtractParameterFromEffect<TRest, 'payload'>, never, TReturn> : RematchDispatcher<true, ExtractParameterFromEffect<TRest, 'payload'>, ExtractParameterFromEffect<TRest, 'meta'>, TReturn> : never;
export interface DevtoolOptions {
    disabled?: boolean;
    name?: string;
    actionCreators?: ActionCreator<any>[] | {
        [key: string]: ActionCreator<any>;
    };
    latency?: number;
    maxAge?: number;
    serialize?: boolean | {
        date?: boolean;
        regex?: boolean;
        undefined?: boolean;
        error?: boolean;
        symbol?: boolean;
        map?: boolean;
        set?: boolean;
        function?: boolean | Function;
    };
    actionSanitizer?: <A extends Action>(action: A, id: number) => A;
    stateSanitizer?: <S>(state: S, index: number) => S;
    actionsBlacklist?: string | string[];
    actionsWhitelist?: string | string[];
    predicate?: <S, A extends Action>(state: S, action: A) => boolean;
    shouldRecordChanges?: boolean;
    pauseActionType?: string;
    autoPause?: boolean;
    shouldStartLocked?: boolean;
    shouldHotReload?: boolean;
    shouldCatchErrors?: boolean;
    features?: {
        pause?: boolean;
        lock?: boolean;
        persist?: boolean;
        export?: boolean | 'custom';
        import?: boolean | 'custom';
        jump?: boolean;
        skip?: boolean;
        reorder?: boolean;
        dispatch?: boolean;
        test?: boolean;
    };
    trace?: boolean | (<A extends Action>(action: A) => string);
    traceLimit?: number;
    [key: string]: any;
}
export interface ModelCreator {
    <RM extends Models<RM>>(): <R extends ModelReducers<S> | undefined, BR extends ReduxReducer<BS> | undefined, E extends ModelEffects<RM> | ModelEffectsCreator<RM> | undefined, S, BS = S>(mo: {
        name?: string;
        state: S;
        reducers?: R;
        baseReducer?: BR;
        effects?: E;
    }) => {
        name?: string;
        state: S;
    } & (E extends undefined ? {} : {
        effects: E;
    }) & (R extends undefined ? {} : {
        reducers: R;
    }) & (BR extends undefined ? {} : {
        baseReducer: BR;
    });
}
declare module 'redux' {
    interface Dispatch<A extends Action = AnyAction> {
        [modelName: string]: any;
    }
}
declare module 'react-redux' {
    interface Connect {
        <RM extends Models<RM>, State, TStateProps, TDispatchProps, TOwnProps>(mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>, mapDispatchToProps: MapRematchDispatchToPropsNonObject<TDispatchProps, TOwnProps, RM>): InferableComponentEnhancerWithProps<TStateProps & TDispatchProps, TOwnProps>;
    }
    type MapRematchDispatchToPropsNonObject<TDispatchProps, TOwnProps, RM extends Models<RM>> = MapRematchDispatchToPropsFactory<TDispatchProps, TOwnProps, RM> | MapRematchDispatchToPropsFunction<TDispatchProps, TOwnProps, RM>;
    type MapRematchDispatchToPropsFactory<TDispatchProps, TOwnProps, RM extends Models<RM>> = (dispatch: any, ownProps: TOwnProps) => MapRematchDispatchToPropsFunction<TDispatchProps, TOwnProps, RM>;
    type MapRematchDispatchToPropsFunction<TDispatchProps, TOwnProps, RM extends Models<RM>> = (dispatch: any, ownProps: TOwnProps) => TDispatchProps;
}
declare global {
    interface Window {
        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: any;
    }
}
export {};
//# sourceMappingURL=types.d.ts.map